# conda create -n gradio_env python=3.10 -y
# conda activate gradio_env
# pip install gradio pandas plotly wordcloud


import pandas as pd
import calendar
from datetime import date
from wordcloud import WordCloud
import plotly.express as px
import gradio as gr

# Data read in

df_cnt = pd.read_csv("data/Connections.csv")
df_cnt["Connected On"] = pd.to_datetime(df_cnt["Connected On"], format="%d-%b-%y", utc=True).dt.tz_convert(None)
df_cnt["month"] = df_cnt["Connected On"].dt.month
df_cnt["month"] = df_cnt["month"].apply(lambda x: calendar.month_abbr[x])

df_invite = pd.read_csv("data/Invitations.csv")
df_invite["Sent At"] = pd.to_datetime(df_invite["Sent At"], format="%m/%d/%y, %I:%M %p", utc=True).dt.tz_convert(None)
df_react = pd.read_csv("data/Reactions.csv")
df_react["Date"] = pd.to_datetime(df_react["Date"], format="%m/%d/%Y %H:%M", utc=True).dt.tz_convert(None)

df_msg = pd.read_csv("data/messages.csv")
df_msg["DATE"] = pd.to_datetime(df_msg["DATE"], utc=True).dt.tz_convert(None)

# Connections 
all_dates = df_cnt["Connected On"].dt.date
date_options = sorted(set(all_dates))  # unique & sort
date_options_str = [d.isoformat() for d in date_options]

default_start = date_options_str[0]
default_end = date_options_str[-1]



def update_dashboard(start_date_str, end_date_str):
    if start_date_str is None or end_date_str is None:
        start_date_str = default_start
        end_date_str = default_end

    start_date = pd.to_datetime(start_date_str)
    end_date = pd.to_datetime(end_date_str)

    # Connections & Companies
    dff_c = df_cnt.copy()
    dff_c = dff_c[(dff_c['Connected On'] >= start_date) & (dff_c['Connected On'] <= end_date)]
    conctns_num = int(len(dff_c))
    compns_num = int(len(dff_c['Company'].unique()))

    # Invitations
    dff_i = df_invite.copy()
    dff_i = dff_i[(dff_i['Sent At'] >= start_date) & (dff_i['Sent At'] <= end_date)]
    in_num = int(len(dff_i[dff_i['Direction'] == 'INCOMING']))
    out_num = int(len(dff_i[dff_i['Direction'] == 'OUTGOING']))

    # Reactions
    dff_r = df_react.copy()
    dff_r = dff_r[(dff_r['Date'] >= start_date) & (dff_r['Date'] <= end_date)]
    reactns_num = int(len(dff_r))

    # ---------- 2) Line Chart ----------

    dff_line = df_cnt.copy()
    dff_line = dff_line[(dff_line['Connected On'] >= start_date) & (dff_line['Connected On'] <= end_date)]
    if len(dff_line) > 0:
        dff_line = dff_line[["month"]].value_counts().to_frame().reset_index()
        dff_line.rename(columns={'count': 'Total connections'}, inplace=True)
    else:
        dff_line = pd.DataFrame({"month": [], "Total connections": []})

    fig_line = px.line(
        dff_line,
        x='month',
        y='Total connections',
        template='ggplot2',
        title="Total Connections by Month Name"
    )
    fig_line.update_traces(mode="lines+markers", fill='tozeroy', line={'color': 'blue'})
    fig_line.update_layout(margin=dict(l=20, r=20, t=30, b=20))

    # Bar Chart 

    dff_bar = df_cnt.copy()
    dff_bar = dff_bar[(dff_bar['Connected On'] >= start_date) & (dff_bar['Connected On'] <= end_date)]
    if len(dff_bar) > 0:
        dff_bar = dff_bar[["Company"]].value_counts().head(6)
        dff_bar = dff_bar.to_frame().reset_index()
        dff_bar.rename(columns={'count': 'Total connections'}, inplace=True)
    else:
        dff_bar = pd.DataFrame({"Company": [], "Total connections": []})

    fig_bar = px.bar(
        dff_bar,
        x='Total connections',
        y='Company',
        template='ggplot2',
        orientation='h',
        title="Total Connections by Company"
    )
    fig_bar.update_yaxes(tickangle=45)
    fig_bar.update_layout(margin=dict(l=20, r=20, t=30, b=20))
    fig_bar.update_traces(marker_color='blue')

    # Pie Chart

    dff_msg = df_msg.copy()
    dff_msg = dff_msg[(dff_msg['DATE'] >= start_date) & (dff_msg['DATE'] <= end_date)]
    msg_sent = int(len(dff_msg[dff_msg['FROM'] == 'Adam Schroeder']))
    msg_rcvd = int(len(dff_msg[dff_msg['FROM'] != 'Adam Schroeder']))

    fig_pie = px.pie(
        names=['Sent', 'Received'],
        values=[msg_sent, msg_rcvd],
        template='ggplot2',
        title="Messages Sent & Received"
    )
    fig_pie.update_layout(margin=dict(l=20, r=20, t=30, b=20))
    fig_pie.update_traces(marker_colors=['lightblue', 'lightcoral'])

    # Word Cloud

    dff_wc = df_cnt.copy()
    dff_wc = dff_wc.Position[
        (dff_wc['Connected On'] >= start_date) & (dff_wc['Connected On'] <= end_date)
    ].astype(str)

    if len(dff_wc) > 0:
        my_wordcloud = WordCloud(
            background_color='white',
            height=275
        ).generate(' '.join(dff_wc))
    else:
        my_wordcloud = WordCloud(
            background_color='white',
            height=275
        ).generate('')

    fig_wordcloud = px.imshow(
        my_wordcloud,
        template='ggplot2',
        title="Total Connections by Position"
    )
    fig_wordcloud.update_layout(margin=dict(l=20, r=20, t=30, b=20))
    fig_wordcloud.update_xaxes(visible=False)
    fig_wordcloud.update_yaxes(visible=False)

    return (
        conctns_num,   # 1
        compns_num,    # 2
        in_num,        # 3
        out_num,       # 4
        reactns_num,   # 5
        fig_line,      # 6
        fig_bar,       # 7
        fig_pie,       # 8
        fig_wordcloud  # 9
    )


# Gradio UI

# app.layout = ...
# Bloacks -> container
with gr.Blocks() as demo:
    gr.Markdown("## LinkedIn Analytics Dashboard (Gradio)")
    
    # dbc.Row
    # you don't need to manually write columns
    with gr.Row():
        start_date_dd = gr.Dropdown(
            choices=date_options_str,
            value=default_start,
            label="Start date"
        )
        end_date_dd = gr.Dropdown(
            choices=date_options_str,
            value=default_end,
            label="End date"
        )

    with gr.Row():
        connections_box = gr.Number(label="Connections") # return a number
        companies_box = gr.Number(label="Companies")
        in_box = gr.Number(label="Invites received")
        out_box = gr.Number(label="Invites sent")
        reactions_box = gr.Number(label="Reactions")

    with gr.Row():
        line_plot = gr.Plot(label="Connections by month") # return a plot
        bar_plot = gr.Plot(label="Top companies")

    with gr.Row():
        pie_plot = gr.Plot(label="Messages sent vs received")
        wc_plot = gr.Plot(label="Wordcloud (Position)")

    start_date_dd.change(
        fn=update_dashboard,
        inputs=[start_date_dd, end_date_dd],
        outputs=[
            connections_box,
            companies_box,
            in_box,
            out_box,
            reactions_box,
            line_plot,
            bar_plot,
            pie_plot,
            wc_plot,
        ],
    )

    end_date_dd.change(
        fn=update_dashboard,
        inputs=[start_date_dd, end_date_dd],
        outputs=[
            connections_box,
            companies_box,
            in_box,
            out_box,
            reactions_box,
            line_plot,
            bar_plot,
            pie_plot,
            wc_plot,
        ],
    )

    demo.load(
        fn=update_dashboard,
        inputs=[start_date_dd, end_date_dd],
        outputs=[
            connections_box,
            companies_box,
            in_box,
            out_box,
            reactions_box,
            line_plot,
            bar_plot,
            pie_plot,
            wc_plot,
        ],
    )

if __name__ == "__main__":
    demo.launch()

# pip freeze -> requirements.txt

"""
Documents: https://www.gradio.app/guides/using-blocks-like-functions
Gradio input components:
gr.Textbox (multiple lines)
gr.Number
gr.TextArea
-----------
gr.Dropdown
gr.Checkbox
gr.CheckboxGroup
gr.Slider
gr.Button
-----------
gr.File
gr.FileExplorer
-----------
gr.Image
gr.Audio
gr.Video
gr.Code
"""


